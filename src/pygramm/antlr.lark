//# A lark parser grammar for Antlr grammars, because there are lots of existing
//# Antlr grammars that we would like to repurpose for fuzzing.
//#

?start: antlr

antlr: (_noise | production)*

//# Antlr constructions we are currently ignoring
_noise:  _naming | _options | _lexer
_naming: "parser"? "grammar" IDENT ";"
_options: "options" "{"  (IDENT "=" IDENT ";")* "}"
//# lexer inclusion is TBD
_lexer:  "lexer" "grammar" IDENT ";"

//# Use Lark pre-built lexical patterns for skipping whitespace
%import common.WS
%ignore WS


//# Additional (virtual) whitespace specific to Antlr
//# These are copied from example Verilog grammar (after failure to write my own)
DOUBLE_SLASH:  "//" /[^\n]*/
%ignore DOUBLE_SLASH
SLASH_STAR:  /\/\*(\*(?!\/)|[^*])*\*\//
%ignore SLASH_STAR
%ignore "EOF"





production: _lhs ":" choices ";"
_lhs: _opt_frag_tag ident
_opt_frag_tag: "fragment"?
?choices: seq ("|" seq)*
seq:  _rhs_item *
_rhs_item: star | plus | optional | _skip | primary
star: _rhs_item "*"
plus: _rhs_item "+"
optional: _rhs_item "?"
_skip:  _rhs_item "->" "skip"
?primary:  ident | token_def | "(" choices ")"


//# Token definitions in Antlr can be strings or regular expressions
?token_def:  literal | regex
literal: /["][^"]*["]/ | /['][^']*[']/
regex:    "~" regex -> negation_unsupported
     | spans
spans: /\[.*\]/

//# Typical pattern for identifiers.  Antlr uses lexical conventions
//# to distinguish terminals from non-terminals, but we can ignore
//# that distinction.
//# Note "ident" is added to grammar symbols, "IDENT" is not.
//# Use "IDENT" where we are skipping over Antlr constructs
//# like naming the grammar.
ident: IDENT
IDENT: /[_a-zA-Z][_a-zA-Z0-9]*/






